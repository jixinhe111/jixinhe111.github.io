<!DOCTYPE html>
<html lang="zh-cn" >
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  
  <meta name="author"
        content="jxh"/>

  
  <meta name="description" content="一、编程规约 (一) 命名风格 1.【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。 2.【强制】所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 3"/>
  

  
  
  <meta name="keywords" content="Hugo, theme, zozo"/>
  

  
  <link rel="canonical" href="https://jixinhe111.github.io/posts/java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/"/>

  

  <title>Java开发手册 &middot; 两只老虎 --from jxh</title>

  <link rel="shortcut icon" href="https://jixinhe111.github.io/images/favicon.ico"/>
  <link rel="stylesheet" href="https://jixinhe111.github.io/css/animate.min.css"/>
  <link rel="stylesheet" href="https://jixinhe111.github.io/css/remixicon.css"/>
  <link rel="stylesheet" href="https://jixinhe111.github.io/css/zozo.css"/>
  <link rel="stylesheet" href="https://jixinhe111.github.io/css/highlight.css"/>

  
  
</head>

<body>
<div class="main animated">
  <div class="nav_container animated fadeInDown">
  <div class="site_nav" id="site_nav">
    <ul>
      
      <li>
        <a href="/">首页</a>
      </li>
      
      <li>
        <a href="/posts/">归档</a>
      </li>
      
      <li>
        <a href="/tags/">标签</a>
      </li>
      
      <li>
        <a href="/about/">关于</a>
      </li>
      
    </ul>
  </div>
  <div class="menu_icon">
    <a id="menu_icon"><i class="remixicon-links-line"></i></a>
  </div>
</div>

  <div class="header animated fadeInDown">
  <div class="site_title_container">
    <div class="site_title">
      <h1>
        <a href="https://jixinhe111.github.io/">
          <span>两只老虎 --from jxh</span>
          <img src="https://jixinhe111.github.io/images/logo.svg"/>
        </a>
      </h1>
    </div>
    <div class="description">
      <p class="sub_title">一只没有眼睛，一只没有耳朵</p>
      <div class="my_socials">
        
        
        <a href="%20" title="facebook" target="_blank"><i class="remixicon-facebook-fill"></i></a>
        
        
        
        <a href="%20" title="github" target="_blank"><i class="remixicon-github-fill"></i></a>
        
        
        
        <a href="%20" title="instagram" target="_blank"><i class="remixicon-instagram-fill"></i></a>
        
        
        
        <a href="%20" title="twitter" target="_blank"><i class="remixicon-twitter-fill"></i></a>
        
        
        
        <a href="%20" title="weibo" target="_blank"><i class="remixicon-weibo-fill"></i></a>
        
        
      </div>
    </div>
  </div>
</div>

  <div class="content">
    <div class="post_page">
      <div class="post animated fadeInDown">
        <div class="post_title post_detail_title">
          <h2><a href='/posts/java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/'>Java开发手册</a></h2>
          <span class="date">2020.06.01</span>
        </div>
        <div class="post_content markdown">

<h3 id="一-编程规约">一、编程规约</h3>

<h4 id="一-命名风格">(一) 命名风格</h4>

<p>1.【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。</p>

<p>2.【强制】所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。</p>

<p>3.【强制】类名使用 UpperCamelCase 风格，但以下情形例外：DO / BO / DTO / VO / AO / PO / UID 等。</p>

<p>4.【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格。</p>

<p>​       localValue / getHttpMessage() / inputUserId</p>

<p>5.【强制】<strong>常量</strong>命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</p>

<p>6.【强制】<strong>抽象类</strong>命名使用 <strong>Abstract 或 Base</strong> 开头；<strong>异常类</strong>命名使用 <strong>Exception</strong> 结尾；<strong>测试类</strong>命名以它要测试的类的名称开始，以 <strong>Test</strong> 结尾。</p>

<p>7.【强制】类型与中括号紧挨相连来表示数组。如<strong>int[]</strong> arrayDemo;</p>

<p>8.【强制】POJO 类中的任何<strong>布尔类型</strong>的变量，都<strong>不要加 is</strong> 前缀，否则部分框架解析会引起序列化错误。</p>

<p>说明：在本文 MySQL 规约中的建表约定第一条，表达是与否的值采用 is_xxx 的命名方式，所以，需要在设置从 is_xxx 到 xxx 的<strong>映射</strong>关系。</p>

<p>9.【强制】<strong>包名</strong>统一使用<strong>小写</strong>，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。如应用工具类包名为 com.alibaba.ei.kunlun.aap.util、类名为 MessageUtils。</p>

<p>10.【强制】避免在<strong>子父类的成员变量之间</strong>、或者<strong>不同代码块的局部变量</strong>之间采用完全相同的命名， 使可读性降低。</p>

<p>11.【强制】杜绝完全不规范的缩写，避免望文不知义。</p>

<p>12.【推荐】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用<strong>尽量完整的单词组合</strong>来表达。</p>

<p>13.【推荐】在常量与变量的命名时，<strong>表示类型的名词放在词尾</strong>，以提升辨识度。</p>

<p>如startTime / workQueue / nameList / TERMINATED_THREAD_COUNT。</p>

<p>14.【推荐】如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。</p>

<p>如public class <strong>OrderFactory</strong>; public class <strong>LoginProxy</strong>; public class <strong>ResourceObserver</strong>;</p>

<p>15.【推荐】<strong>接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。</strong>尽量不要在接口里定义变量，如果一定要定义变量，确定 与接口方法相关，并且是整个应用的基础常量。</p>

<p>16.接口和实现类的命名有两套规则：</p>

<p>1）【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，<strong>内部的实现类用 Impl 的后缀与接口区别</strong>。</p>

<p>2）【推荐】如果是形容能力的接口名称，<strong>取对应的形容词为接口名</strong>（通常是–able 的形容词）。</p>

<p>如AbstractTranslator 实现 Translatable 接口。</p>

<p>17.【参考】枚举类名带上 Enum 后缀，枚举成员名称需要全<strong>大写</strong>，单词间用<strong>下划线隔开</strong>。</p>

<p>18.【参考】各层命名规约：】</p>

<p>A) Service/DAO 层方法命名规约</p>

<p>​   1） 获取<strong>单个</strong>对象的方法用 <strong>get</strong> 做<strong>前缀</strong>。</p>

<p>​   2） 获取<strong>多个</strong>对象的方法用 <strong>list</strong> 做<strong>前缀</strong>，复数结尾，如：listObjects。</p>

<p>​   3） 获取统计值的方法用 count 做前缀。</p>

<p>​   4） 插入的方法用 save/insert 做前缀。</p>

<p>​   5） 删除的方法用 remove/delete 做前缀。</p>

<p>​   6） 修改的方法用 update 做前缀。</p>

<p>B) 领域模型命名规约</p>

<p>​   1） 数据对象：xxxDO，xxx 即为数据表名。</p>

<p>​   2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</p>

<p>​   3） 展示对象：xxxVO，xxx 一般为网页名称。</p>

<p>​   4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。</p>

<h4 id="二-常量定义">(二) 常量定义</h4>

<p>1.【强制】不允许任何魔法值（即<strong>未经预先定义的常量</strong>）直接出现在代码中。</p>

<p>反例： //本例中同学 A 定义了缓存的 key，然后缓存提取的同学 B 使用了 Id#taobao 来提取，少了下划线，导致故障。</p>

<p>String key = &quot;Id#taobao_&quot; + tradeId;</p>

<p>cache.put(key, value);</p>

<p>2.【强制】在 long 或者 Long 赋值时，数值后使用<strong>大写的 L</strong>，不能是小写的 l，小写容易跟数字混淆，造成误解。</p>

<p>3.【推荐】<strong>不要使用一个常量类维护所有常量</strong>，要按常量功能进行归类，分开维护。</p>

<p>如：缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 ConfigConsts 下。</p>

<p>4.【推荐】<strong>常量的复用层次有五层</strong>：跨应用共享常量、应用内共享常量、子工程内共享常量、包 内共享常量、类内共享常量。</p>

<p>​   1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。</p>

<p>​   2） 应用内共享常量：放置在一方库中，通常是子模块中的 constant 目录下。 反例：易懂变量也要统一定义成应用内共享常量，两位工程师在两个类中分别定义了“YES”的变量： 类 A 中：public static final String YES = &quot;yes&quot;; 类 B 中：public static final String YES = &quot;y&quot;; A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致线上问题。</p>

<p>​   3） 子工程内部共享常量：即在当前子工程的 constant 目录下。</p>

<p>​   4） 包内共享常量：即在当前包下单独的 constant 目录下。</p>

<p>​   5） 类内共享常量：直接在类内部 private static final 定义。</p>

<p>5.【推荐】如果变量值仅在一个固定范围内变化用 <strong>enum</strong> 类型来定义。</p>

<p>说明：如果存在名称之外的延伸属性应使用 enum 类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节。</p>

<h4 id="三-代码格式">(三) 代码格式</h4>

<p>1.【强制】如果是<strong>大括号内为空，则简洁地写成{}即可</strong>，大括号中间无需换行和空格；如果是<strong>非空代码块</strong>则：</p>

<p>​       1） 左大括号前不换行。</p>

<p>​       2） 左大括号后换行。</p>

<p>​       3） 右大括号前换行。</p>

<p>​       4） 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。</p>

<p>2.【强制】左小括号和右边相邻字符之间不出现空格；右小括号和左边相邻字符之间也不出现空格；而<strong>左大括号前需要加空格</strong>。</p>

<p>反例：if (空格 a == b 空格)</p>

<p>3.【强制】if/for/while/switch/do 等保留字与括号之间都<strong>必须加空格</strong>。</p>

<p>4.【强制】任何<strong>二目、三目运算符</strong>的左右两边都需要加一个空格。</p>

<p>说明：包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等。</p>

<p>5.【强制】采用 4 个空格缩进，禁止使用 tab 字符。</p>

<p>说明：如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，请勿勾选 Use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。</p>

<p>6.【强制】注释的双斜线与注释内容之间有且仅有一个空格。</p>

<p>7.【强制】在进行类型强制转换时，右括号与强制转换值之间不需要任何空格隔开。</p>

<p>8.【强制】单行字符数限制<strong>不超过 120 个</strong>，超出需要换行，换行时遵循如下原则：</p>

<p>​   1）第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进。</p>

<p>​   2）<strong>运算符</strong>与下文一起换行。</p>

<p>​   3）方法调用的<strong>点符号</strong>与下文一起换行。</p>

<p>​   4）方法调用中的多个参数需要换行时，<strong>在逗号后进行</strong>。</p>

<p>​   5）<strong>在括号前不要换行</strong>。</p>

<p>9.【强制】方法参数在定义和传入时，<strong>多个参数逗号后边必须加空格</strong>。</p>

<p>10.【强制】IDE 的 text file encoding 设置为 <strong>UTF-8</strong>; IDE 中文件的<strong>换行符</strong>使用 <strong>Unix</strong> 格式，不要使用 Windows 格式。</p>

<p>11.【推荐】单个方法的总行数<strong>不超过 80 行</strong>。</p>

<p>12.【推荐】没有必要增加若干空格来使变量的赋值等号与上一行对应位置的等号对齐。</p>

<p>13.【推荐】不同逻辑、不同语义、不同业务的代码之间插入<strong>一个空行</strong>分隔开来以提升可读性。</p>

<h4 id="四-oop规约">(四) OOP规约</h4>

<p>1.【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用<strong>类名</strong>来访问即可。</p>

<p>2.【强制】所有的覆写方法，必须加@Override 注解。</p>

<p>3.【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。可变参数必须放置在参数列表的最后。</p>

<p>4.【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。</p>

<p>5.【强制】不能使用过时的类或方法。</p>

<p>6.【强制】Object 的 equals 方法容易抛空指针异常，应使用<strong>常量或确定有值的对象来调用 equals</strong>。如“test”.equals(Object);</p>

<p>7.【强制】所有整型包装类对象之间<strong>值的比较</strong>，全部使用 equals 方法比较。</p>

<p>8.【强制】任何货币金额，均以最小货币单位且整型类型来进行存储。</p>

<p>9.【强制】浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。建议使用<strong>BigDecimal</strong>类。</p>

<p>10.【强制】定义数据对象 DO 类时，属性<strong>类型</strong>要与数据库字段类型相匹配。</p>

<p>11.【强制】<strong>禁止</strong>使用构造方法 BigDecimal(double)的方式<strong>把 double 值转化为 BigDecimal 对象</strong>。存在精度损失风险。优先推荐入参为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法。</p>

<p>12.关于基本数据类型与包装数据类型的使用标准如下：</p>

<p>​   1）【强制】所有的 <strong>POJO 类</strong>属性必须使用<strong>包装数据类型</strong>避免NPE问题。</p>

<p>​   2）【强制】<strong>RPC 方法</strong>的返回值和参数必须使用<strong>包装数据类型</strong>。</p>

<p>​   3）【推荐】所有的<strong>局部变量</strong>使用<strong>基本数据类型</strong>。</p>

<p>13.【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性<strong>默认值</strong>。</p>

<p>14.【强制】<strong>序列化</strong>类新增属性时，请<strong>不要修改 serialVersionUID</strong> 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。 说明：注意 serialVersionUID 不一致会抛出序列化运行时异常。private static final long serialVersionUID。</p>

<p>15.【强制】<strong>构造方法里面禁止加入任何业务逻辑</strong>，如果有初始化逻辑，请放在 init 方法中。</p>

<p>16.【强制】POJO 类必须写 toString 方法。使用 IDE 中的工具：source&gt; generate toString 时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。</p>

<p>17.【强制】禁止在 POJO 类中，同时存在对应属性 xxx 的 isXxx()和 getXxx()方法。</p>

<p>说明：框架在调用属性 xxx 的提取方法时，并不能确定哪个方法一定是被优先调用到，<strong>神坑之一</strong>。</p>

<p>18.【推荐】使用索引访问用 <strong>String 的 split 方法得到的数组</strong>时，需做最后一个分隔符后有无内容的<strong>检查</strong>，否则会有抛 IndexOutOfBoundsException 的风险。</p>

<p>19.【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此条规则优先于下一条。</p>

<p>20.【推荐】 类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter / setter 方法。</p>

<p>21.【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在 getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度。</p>

<p>22.【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。</p>

<p>23.【推荐】final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字：</p>

<p>​       1） 不允许被继承的类，如：String 类。</p>

<p>​       2） 不允许修改引用的域对象，如：POJO 类的域变量。</p>

<p>​       3） 不允许被覆写的方法，如：POJO 类的 setter 方法。</p>

<p>​       4） 不允许运行过程中重新赋值的局部变量。</p>

<p>​       5） 避免上下文重复使用一个变量，使用 final 可以强制重新定义一个变量，方便更好地进行重构。</p>

<p>24.【推荐】慎用 Object 的 clone 方法来拷贝对象。（浅拷贝深拷贝）</p>

<p>25.【推荐】类成员与方法访问控制<strong>从严</strong>：</p>

<p>​   1） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。</p>

<p>​   2） 工具类不允许有 public 或 default 构造方法。</p>

<p>​   3） 类非 static 成员变量并且与子类共享，必须是 protected。</p>

<p>​   4） 类非 static 成员变量并且仅在本类使用，必须是 private。</p>

<p>​   5） 类 static 成员变量如果仅在本类使用，必须是 private。</p>

<p>​   6） 若是 static 成员变量，考虑是否为 final。</p>

<p>​   7） 类成员方法只供类内部调用，必须是 private。</p>

<p>​   8） 类成员方法只对继承类公开，那么限制为 protected。</p>

<h4 id="五-日期时间">(五) 日期时间</h4>

<p>1.【强制】日期格式化时，传入 pattern 中表示年份统一使用<strong>小写</strong>的 y。</p>

<p>表示日期和时间的格式如下所示： new SimpleDateFormat(&quot;<strong>yyyy-MM-dd HH:mm:ss</strong>&quot;)</p>

<p>2.【强制】在日期格式中分清楚大写的 M 和小写的 m，大写的 H 和小写的 h 分别指代的意义。</p>

<p>日期格式中的这两对字母表意如下：</p>

<p>​       1） 表示月份是大写的 M；</p>

<p>​       2） 表示分钟则是小写的 m；</p>

<p>​       3） 24 小时制的是大写的 H；</p>

<p>​       4） 12 小时制的则是小写的 h。</p>

<p>3.【强制】获取当前毫秒数：System.currentTimeMillis(); 而不是 new Date().getTime()。</p>

<p>4.【强制】不允许在程序任何地方中使用：1）java.sql.Date 2）java.sql.Time 3） java.sql.Timestamp。</p>

<p>5.【强制】不要在程序中写死一年为 365 天，避免在公历闰年时出现日期转换错误或程序逻辑错误。</p>

<p>6.【推荐】避免公历闰年 2 月问题。闰年的 2 月份有 29 天，一年后的那一天不可能是 2 月 29 日。</p>

<p>7.【推荐】使用<strong>枚举</strong>值来指代月份。如果使用数字，注意 Date，Calendar 等日期相关类的月份 month 取值在 <strong>0-11</strong> 之间。</p>

<h4 id="六-集合处理">(六) 集合处理</h4>

<p>1.【强制】关于 hashCode 和 equals 的处理，遵循如下规则：</p>

<p>​       1） <strong>只要重写 equals，就必须重写 hashCode。</strong></p>

<p>​       2） 因为 <strong>Set</strong> 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象<strong>必须重写</strong>这两个方法。</p>

<p>​       3） 如果自定义对象作为 <strong>Map</strong> 的键，那么<strong>必须覆写</strong> hashCode 和 equals。</p>

<p>2.【强制】判断所有集合内部的元素是否为空，使用 <strong>isEmpty()</strong>方法，而不是 size()==0 的方式。</p>

<p>*3.【强制】在使用 java.util.stream.Collectors 类的 toMap()方法转为 Map 集合时，一定要使用<strong>含有参数类型为 BinaryOperator，参数名为 mergeFunction 的方法</strong>，否则当出现相同 key 值时会抛出 IllegalStateException 异常。</p>

<p>4.【强制】在使用 java.util.stream.Collectors 类的 toMap()方法转为 Map 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。</p>

<p>5.【强制】ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异 常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList。</p>

<p>说明：subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList 而是 ArrayList 的一个视图，对 于 SubList 子列表的所有操作最终会反映到原列表上。</p>

<p>6.【强制】使用 Map 的方法 keySet()/values()/entrySet()返回集合对象时，<strong>不可以对其进行添加元素操作</strong>，否则会抛出 UnsupportedOperationException 异常。</p>

<p>7.【强制】Collections 类返回的对象，如：emptyList()/singletonList()等都是 <strong>immutable list</strong>， <strong>不可对其进行添加或者删除元素的操作</strong>。</p>

<p>8.【强制】在 subList 场景中，高度注意对父集合元素的增加或删除，均会导致子列表的遍历、 增加、删除产生 ConcurrentModificationException 异常。</p>

<p>9.【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是<strong>类型完全一致、长度为 0</strong> 的空数组。如：String[] array = list.toArray(new String[0]);</p>

<p>10.【强制】在使用 Collection 接口任何实现类的addAll()方法时，都要对输入的集合参数<strong>进行 NPE 判断</strong>。</p>

<p>说明：在 ArrayList#addAll 方法的<strong>第一行</strong>代码即 Object[] a = c.toArray(); 其中 c 为输入集合参数，如果 为 null，则直接抛出异常。</p>

<p>11.【强制】使用工具类 Arrays.asList()把数组转换成集合时，<strong>不能使用其修改集合相关的方法</strong>，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。</p>

<p>说明：asList 的返回对象是一个 Arrays 内部类，<strong>并没有实现集合的修改方法</strong>。Arrays.asList 体现的是<strong>适配器模式</strong>，只是转换接口，后台的数据仍是数组。</p>

<p>12.【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合<strong>不能使用 add 方法</strong>， 而&lt;? super T&gt;<strong>不能使用 get 方法</strong>，两者在接口调用赋值的场景中容易出错。</p>

<p>13.【强制】在无泛型限制定义的集合赋值给泛型限制的集合时，在使用集合元素时，需要进行 instanceof 判断，避免抛出 ClassCastException 异常。</p>

<p>14.【强制】<strong>不要在 foreach 循环里进行元素的 remove/add 操作</strong>。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。</p>

<p>15.【强制】在 JDK7 版本及以上，Comparator 实现类要<strong>满足如下三个条件</strong>，不然 Arrays.sort， Collections.sort 会抛 IllegalArgumentException 异常。</p>

<p>三个条件如下</p>

<p>​       1） x，y 的比较结果和 y，x 的比较结果相反。</p>

<p>​               反例：return o1.getId() &gt; o2.getId() ? 1 : -1; //没有处理相等的情况</p>

<p>​       2） x&gt;y，y&gt;z，则 x&gt;z。</p>

<p>​       3） x=y，则 x，z 比较结果和 y，z 比较结果相同。</p>

<p>16.【推荐】集合泛型定义时，在 JDK7 及以上，使用 diamond 语法或全省略。菱形泛型，即 diamond，<strong>直接使用&lt;&gt;来指代前边已经指定的类型</strong>。</p>

<p>17.【推荐】集合初始化时，指定集合初始值大小。</p>

<p>18.【推荐】使用 <strong>entrySet</strong> 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。</p>

<p>19.【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况。</p>

<p>20.【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳 定性(unorder)带来的负面影响。</p>

<p>21.【参考】利用 <strong>Set</strong> 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains()进行遍历去重或者判断包含操作。</p>

<h4 id="七-并发处理">(七) 并发处理</h4>

<p>1.【强制】获取<strong>单例对象</strong>需要保证<strong>线程安全</strong>，其中的方法也要保证线程安全。</p>

<p>2.【强制】创建线程或线程池时请<strong>指定有意义的线程名称</strong>，方便出错时回溯。</p>

<p>3.【强制】线程资源必须通过<strong>线程池</strong>提供，不允许在应用中自行显式创建线程。</p>

<p>4.【强制】<strong>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式</strong>，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>

<p>5.【强制】<strong>SimpleDateFormat</strong> 是<strong>线程不安全</strong>的类，一般<strong>不要定义为 static 变量</strong>，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。</p>

<p>6.【强制】必须回收自定义的 <strong>ThreadLocal</strong> 变量，尤其在线程池场景下，线程经常会被复用， 如果不清理自定义的 ThreadLocal 变量，可能会<strong>影响后续业务逻辑和造成内存泄露</strong>等问题。 尽量在代理中<strong>使用 try-finally 块进行回收</strong>。</p>

<p>7.【强制】高并发时，同步调用应该去考量锁的性能损耗。能用<strong>无锁</strong>数据结构，就不要用锁；能锁<strong>区块</strong>，就不要锁整个<strong>方法体</strong>；能用<strong>对象</strong>锁，就不要用<strong>类</strong>锁。</p>

<p>8.【强制】对多个资源、数据库表、对象同时加锁时，需要保持<strong>一致的加锁顺序</strong>，否则可能会造成<strong>死锁</strong>。</p>

<p>9.【强制】在<strong>使用阻塞等待获取锁</strong>的方式中，<strong>必须在 try 代码块之外</strong>，并且在加锁方法与 try 代码块之间<strong>没有任何可能抛出异常的方法调用</strong>，避免加锁成功后，在 finally 中无法解锁。</p>

<p>Lock lock = new XxxLock();</p>

<p>// ...</p>

<p>lock.lock();</p>

<p>try {</p>

<p>​       doSomething();</p>

<p>​       doOthers();</p>

<p>} finally {</p>

<p>​       lock.unlock();</p>

<p>}</p>

<p>10.【强制】在使用尝试机制<strong>tryLock()</strong>来获取锁的方式中，进入业务代码块之前，必须<strong>先判断当前线程是否持有锁</strong>。锁的释放规则与锁的阻塞等待方式相同。</p>

<p>11.【强制】<strong>并发修改同一记录</strong>时，避免更新丢失，需要<strong>加锁</strong>。要么在应用层加锁，要么在缓存加 锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。</p>

<p>12.【强制】多线程并行处理定时任务时，<strong>Timer</strong> 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 <strong>ScheduledExecutorService</strong> 则没有这个问题。</p>

<p>13.【推荐】<strong>资金相关的金融敏感信息</strong>，使用<strong>悲观锁</strong>策略。</p>

<p>14.【推荐】使用 <strong>CountDownLatch</strong> 进行异步转同步操作，每个线程退出前必须调用 countDown 方 法，线程执行代码<strong>注意 catch 异常</strong>，<strong>确保 countDown 方法被执行到</strong>，避免主线程无法执行至 await 方法，直到超时才返回结果。</p>

<p>15.【推荐】<strong>避免 Random 实例被多线程使用</strong>，虽然共享该实例是线程安全的，但会因竞争同一 seed 导致的性能下降。</p>

<p>16.【推荐】通过<strong>双重检查锁</strong>（double-checked locking）（在并发场景下）实现延迟初始化的优化 问题隐患(可参考 The &quot;Double-Checked Locking is Broken&quot; Declaration)，推荐解决方案中较为 简单一种（适用于 JDK5 及以上版本），将目标属性声明为 <strong>volatile</strong> 型（比如修改 helper 的属 性声明为<code>private volatile Helper helper = null;</code>）。</p>

<p>17.【参考】<strong>volatile</strong> 解决多线程内存不可见问题。对于<strong>一写多读</strong>，是可以解决变量同步问题，但 是如果<strong>多写</strong>，同样无法解决线程安全问题。</p>

<p>18.【参考】<strong>HashMap</strong> 在容量不够进行 <strong>resize</strong> 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。</p>

<p>19.【参考】<strong>ThreadLocal</strong> 对象使用 <strong>static</strong> 修饰，<strong>ThreadLocal</strong> 无法解决共享对象的更新问题。这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量， 也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可 以操控这个变量。</p>

<h4 id="八-控制语句">(八) 控制语句</h4>

<p>1.【强制】在一个 switch 块内，每个 case 要么通过 continue/break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都<strong>必须包含一个 default语句并且放在最后，即使它什么代码也没有</strong>。</p>

<p>2.【强制】当 switch 括号内的变量类型为 String 并且此变量为外部参数时，必须先进行 null 判断。</p>

<p>3.【强制】在 if/else/for/while/do 语句中必须使用大括号。即使只有一行代码，禁止不采用大括号的编码方式。</p>

<p>4.三目运算符 condition? 表达式 1 : 表达式 2 中，高度注意表达式 1 和 2 在类型对齐时，可能抛出因自动拆箱导致的 NPE 异常。</p>

<p>5.【强制】在高并发场景中，<strong>避免使用”等于”判断</strong>作为中断或退出的条件。如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用<strong>大于或小于</strong>的区间判断条件 来代替。</p>

<p>6.【推荐】当某个方法的代码行数超过 <strong>10</strong> 行时，return / throw 等中断逻辑的右大括号后加一个空行。</p>

<p>7.【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成：</p>

<p>if (condition) {</p>

<p>​       ...</p>

<p>​       return obj;</p>

<p>}</p>

<p>// 接着写 else 的业务逻辑代码;</p>

<p>如果非使用 if()...else if()...else...方式表达逻辑，避免后续代码维护困难，请勿超过 <strong>3</strong> 层。</p>

<p>超过 3 层的 if-else 的逻辑判断代码可以使用<strong>卫语句（把复杂的条件表达式拆分成多个条件表达式）、策略模式、状态模式</strong>等来实现。</p>

<p>8.【推荐】除常用方法（如 getXxx/isXxx）等外，<strong>不要在条件判断中执行其它复杂的语句</strong>，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以<strong>提高可读性</strong>。</p>

<p>9.【推荐】<strong>不要</strong>在其它表达式（<strong>尤其是条件表达式</strong>）中，<strong>插入赋值语句</strong>。</p>

<p>10.【推荐】<strong>循环体中的语句</strong>要考量<strong>性能</strong>，以下操作尽量移至<strong>循环体外</strong>处理，如<strong>定义对象、变量、 获取数据库连接</strong>，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。</p>

<p>11.【推荐】避免采用取反逻辑运算符。</p>

<p>12.【推荐】<strong>接口入参保护</strong>，这种场景常见的是用作<strong>批量</strong>操作的接口。</p>

<p>13.【参考】下列情形，<strong>需要</strong>进行<strong>参数校验</strong>：</p>

<p>​       1） 调用频次低的方法。</p>

<p>​       2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致 中间执行回退，或者错误，那得不偿失。</p>

<p>​       3） 需要极高稳定性和可用性的方法。</p>

<p>​       4） 对外提供的开放接口，不管是 RPC/API/HTTP 接口。</p>

<p>​       5） 敏感权限入口。</p>

<p>14.【参考】下列情形，<strong>不需要</strong>进行<strong>参数校验</strong>：</p>

<p>​       1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查。</p>

<p>​       2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露 问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可 以省略。</p>

<p>​       3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检 查或者肯定不会有问题，此时可以不校验参数。</p>

<h4 id="九-注释规约">(九) 注释规约</h4>

<p>1.【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/**内容*/格式，不得使用 // xxx 方式。</p>

<p>2.【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了<strong>返回值、参数、 异常</strong>说明外，还必须指出该方法<strong>做什么事情，实现什么功能</strong>。</p>

<p>3.【强制】所有的<strong>类</strong>都必须添加<strong>创建者和创建日期</strong>。</p>

<p>4.【强制】方法内部<strong>单行注释</strong>，<strong>在被注释语句上方另起一行</strong>，使用//注释。方法内部多行注释使 用/* */注释，注意与代码对齐。</p>

<p>5.【强制】所有的<strong>枚举</strong>类型字段必须要有<strong>注释</strong>，说明<strong>每个数据项</strong>的<strong>用途</strong>。</p>

<p>6.【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持 英文原文即可。</p>

<p>7.【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。</p>

<p>8.【推荐】在类中删除未使用的任何字段和方法；在方法中删除未使用的任何参数声明与内部变量。</p>

<p>9.【参考】谨慎<strong>注释掉代码</strong>。<strong>在上方详细说明</strong>，而不是简单地注释掉。如果无用，则删除。</p>

<p>10.【参考】对于注释的要求：第一、能够准确反映设计思想和代码逻辑；第二、能够描述业务含 义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看 的，使其能够快速接替自己的工作。</p>

<p>11.【参考】好的命名、代码结构是<strong>自解释</strong>的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。</p>

<p>12.【参考】<strong>特殊注释标记</strong>，请注明标记人与标记时间。注意<strong>及时处理</strong>这些标记，通过标记扫描， 经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。</p>

<h4 id="十-其它">(十) 其它</h4>

<p>1.【强制】在使用<strong>正则表达式</strong>时，利用好其<strong>预编译</strong>功能，可以有效加快正则匹配速度。</p>

<p>不要在方法体内定义：Pattern pattern = <strong>Pattern.compile</strong>(“规则”);</p>

<p>2.【强制】<strong>避免</strong>用 Apache <strong>Beanutils</strong> 进行<strong>属性的 copy</strong>。Apache BeanUtils 性能较差，可以使用其他方案比如 Spring BeanUtils, Cglib BeanCopier，注意均是<strong>浅拷贝</strong>。</p>

<p>*3.【强制】velocity 调用 POJO 类的属性时，直接使用属性名取值即可，模板引擎会自动按规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is 前缀），会自动调用 isXxx()方法。</p>

<p>4.【强制】后台输送给页面的变量必须加<strong>$!{var}</strong>——中间的感叹号。</p>

<p>5.【强制】注意 <strong>Math.random()</strong> 这个方法返回是 <strong>double</strong> 类型，注意取值的范围 0≤x&lt;1（能够 取到零值，注意除零异常），如果想获取<strong>整数类型</strong>的随机数，不要将 x 放大 10 的若干倍然后取整，<strong>直接使用 Random 对象的 nextInt 或者 nextLong 方法</strong>。</p>

<p>6.【推荐】不要在视图模板中加入任何复杂的逻辑。</p>

<p>7.【推荐】<strong>任何</strong>数据结构的<strong>构造或初始化</strong>，都应<strong>指定大小</strong>，避免数据结构无限增长吃光内存。</p>

<p>8.【推荐】<strong>及时清理</strong>不再使用的<strong>代码段</strong>或<strong>配置信息</strong>。</p>

<h3 id="二-异常日志">二、异常日志</h3>

<h4 id="一-错误码">(一) 错误码</h4>

<p>1.【强制】错误码的制定原则：快速溯源、简单易记、沟通标准化。</p>

<p>2.【强制】错误码不体现版本号和错误等级信息。</p>

<p>3.【强制】<strong>全部正常</strong>，但不得不填充错误码时返回五个零：<strong>00000</strong>。</p>

<p>4.【强制】错误码为字符串类型，共 <strong>5</strong> 位，分成两个部分：<strong>错误产生来源</strong>+<strong>四位数字编号</strong>。</p>

<p>说明：错误产生来源分为 A/B/C，A 表示错误来源于用户，比如参数错误，用户安装版本过低，用户支付 超时等问题；B 表示错误来源于当前系统，往往是业务逻辑出错，或程序健壮性差等问题；C 表示错误来源 于第三方服务，比如 CDN 服务出错，消息投递超时等问题；四位数字编号从 0001 到 9999，<strong>大类之间的 步长间距预留 100</strong>，参考文末附表 3。</p>

<p>5.【强制】编号不与公司业务架构，更不与组织架构挂钩，一切与平台先到先申请的原则进行， 审批生效，编号即被永久固定。</p>

<p>6.【强制】错误码使用者避免随意定义新的错误码。</p>

<p>7.【强制】错误码<strong>不能直接输出</strong>给用户作为提示信息使用。</p>

<p>8.【推荐】错误码之外的业务独特信息由 <strong>error_message</strong> 来承载，而不是让错误码本身涵盖过多具体业务属性。</p>

<p>9.【推荐】在获取第三方服务错误码时，向上抛出允许本系统转义，由 C 转为 B，并且在错误信息上带上原有的第三方错误码。</p>

<p>10.【参考】错误码分为一级宏观错误码、二级宏观错误码、三级宏观错误码。调用第三方服务出错是一级，中间件错误是二级，消息服务出错是三级。</p>

<p>11.【参考】错误码的后三位编号与 HTTP 状态码没有任何关系。</p>

<p>12.【参考】错误码尽量有利于不同文化背景的开发者进行交流与代码协作。</p>

<p>13.【参考】错误码即人性，感性认知+口口相传，使用纯数字来进行错误码编排不利于感性记忆和分类。</p>

<h4 id="二-异常处理">(二) 异常处理</h4>

<p>1.【强制】Java 类库中定义的可以通过预检查方式规避的 <strong>RuntimeException</strong> 异常<strong>不应该通过 catch</strong> 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException 等等。</p>

<p>2.【强制】异常不要用来做流程控制，条件控制。</p>

<p>3.【强制】catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。 对于非稳定代码的 catch <strong>尽可能进行区分异常类型</strong>，再做对应的异常处理。</p>

<p>4.【强制】<strong>捕获异常是为了处理它</strong>，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请 将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的 内容。</p>

<p>5.【强制】<strong>事务场景</strong>中，抛出异常被 <strong>catch</strong> 后，如果需要回滚，一定要注意<strong>手动回滚</strong>事务。</p>

<p>6.【强制】finally 块必须对<strong>资源对象、流对象</strong>进行关闭，有异常也要做 try-catch。</p>

<p>7.【强制】<strong>不要在 finally 块中使用 return</strong>。</p>

<p>8.【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。</p>

<p>*9.【强制】在调用 <strong>RPC、二方包、或动态生成类</strong>的相关方法时，捕捉异常必须使用 <strong>Throwable</strong> 类来进行拦截。</p>

<p>10.【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。</p>

<p>11.【推荐】<strong>防止 NPE</strong>，是程序员的基本修养，注意 NPE 产生的场景：</p>

<p>​       1） 返回类型为基本数据类型，return 包装数据类型的对象时，<strong>自动拆箱</strong>有可能产生 NPE。 反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。</p>

<p>​       2） <strong>数据库的查询结果</strong>可能为 null。</p>

<p>​       3） <strong>集合</strong>里的元素即使 isNotEmpty，取出的数据元素也可能为 null。</p>

<p>​       4） <strong>远程调用</strong>返回对象时，一律要求进行空指针判断，防止 NPE。</p>

<p>​       5） 对于 <strong>Session</strong> 中获取的数据，建议进行 NPE 检查，避免空指针。</p>

<p>​       6） <strong>级联调用</strong> obj.getA().getB().getC()；一连串调用，易产生 NPE。</p>

<p>12.【推荐】定义时区分 unchecked / checked 异常，避免直接抛出 new RuntimeException()，更不允许抛出 Exception 或者 Throwable，应使用有<strong>业务含义</strong>的<strong>自定义异常</strong>。推荐业界已定义过的自定义异常，如：DAOException / ServiceException 等。</p>

<p>13.【参考】对于<strong>公司外的 http/api 开放接口</strong>必须使用<strong>“错误码”</strong>；而应用<strong>内部</strong>推荐<strong>异常</strong>抛出； 跨应用间 <strong>RPC</strong> 调用优先考虑使用 <strong>Result</strong> 方式，封装 isSuccess()方法、“错误码”、“错误简短信息”；而应用<strong>内部</strong>推荐<strong>异常</strong>抛出。</p>

<p>14.【参考】<strong>避免</strong>出现<strong>重复的代码</strong>（Don't Repeat Yourself），即 DRY 原则。随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。 必要时抽取共性方法，或者抽象公共类，甚至是组件化。</p>

<h4 id="三-日志规约">(三) 日志规约</h4>

<p>1.【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架 （<strong>SLF4J</strong>、<strong>JCL</strong>--Jakarta Commons Logging）中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p>

<p>2.【强制】所有日志文件至少保存 <strong>15</strong> 天，因为有些异常具备以“周”为频次发生的特点。对于当天日志，以“应用名.log”来保存，保存在/home/admin/应用名/logs/目录下， 过往日志格式为: {logname}.log.{保存日期}，日期格式：yyyy-MM-dd。</p>

<p>3.【强制】应用中的<strong>扩展日志</strong>（如打点、临时监控、访问日志等）命名方式： <strong>appName_logType_logName.log</strong>。logType:日志类型，如 stats/monitor/access 等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。</p>

<p>4.【强制】在日志输出时，字符串变量之间的拼接使用<strong>占位符</strong>的方式。因为 String 字符串的拼接会使用 StringBuilder 的 append()方式，有一定的性能损耗。使用占位符仅 是替换动作，可以有效提升性能。</p>

<p>5.【强制】对于 trace/debug/info 级别的日志输出，必须进行日志级别的<strong>开关判断</strong>。</p>

<p>6.【强制】<strong>避免重复</strong>打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。</p>

<p>7.【强制】生产环境<strong>禁止</strong>直接使用 <strong>System.out 或 System.err</strong> 输出日志或使用 <strong>e.printStackTrace</strong>()打印异常堆栈。</p>

<p>8.【强制】异常信息应该包括两类信息：<strong>案发现场</strong>信息和<strong>异常堆栈</strong>信息。如果不处理，那么通过关键字 throws 往上抛出。</p>

<p>9.【强制】日志打印时<strong>禁止</strong>直接用 <strong>JSON 工具</strong>将对象转换成 <strong>String</strong>。打印日志时仅打印出业务相关属性值或者调用其对象的 toString()方法。如果对象里某些 get 方法被重写，<strong>存在抛出异常的情况</strong>，则可能会因为打印日志而影响正常业务流程的执行。</p>

<p>10.【推荐】谨慎地记录日志。生产环境<strong>禁止</strong>输出 <strong>debug</strong> 日志；<strong>有选择</strong>地输出 <strong>info</strong> 日志；如果使用 <strong>warn</strong> 来记录刚上线时的业务行为信息，一定要注意日志<strong>输出量</strong>的问题，避免把服务器磁盘撑爆，并记得<strong>及时删除</strong>这些观察日志。</p>

<p>11.【推荐】可以使用 <strong>warn</strong> 日志级别来记录<strong>用户</strong>输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出 error 级别，避免频繁报警。注意日志输出的级别，<strong>error</strong> 级别只记录<strong>系统</strong>逻辑出错、异常或者重要的错误信息。</p>

<p>12.【推荐】尽量用英文来描述日志错误信息，如果日志中的错误信息用英文描述不清楚的话使用 中文描述即可，否则容易产生歧义。</p>

<h3 id="三-单元测试">三、单元测试</h3>

<p>1.【强制】好的单元测试必须遵守 <strong>AIR 原则</strong>。</p>

<p>单元测试在线上运行时，感觉像空气（AIR）一样并不存在，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。</p>

<p>​      A：Automatic（自动化）</p>

<p>​      I：Independent（独立性）</p>

<p>​      R：Repeatable（可重复）</p>

<p>2.【强制】单元测试应该是<strong>全自动执行</strong>的，并且非交互式的。测试用例通常是被定期执行的，执 行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。</p>

<p>3.【强制】保持单元测试的<strong>独立性</strong>。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。</p>

<p>4.【强制】单元测试是<strong>可以重复执行</strong>的，不能受到外界环境的影响。</p>

<p>5.【强制】对于单元测试，要保证<strong>测试粒度足够小</strong>，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。</p>

<p>6.【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过。</p>

<p>7.【强制】单元测试代码必须写在如下工程目录：<strong>src/test/java</strong>，不允许写在业务代码目录下。</p>

<p>8.【推荐】单元测试的基本目标：语句覆盖率达到 70%；核心模块的语句覆盖率和分支覆盖率都 要达到 100%。</p>

<p>9.【推荐】编写单元测试代码遵守 <strong>BCDE 原则</strong>，以保证被测试模块的交付质量。</p>

<p>​       B：Border，<strong>边界值测试</strong>，包括循环边界、特殊取值、特殊时间点、数据顺序等。</p>

<p>​       C：Correct，<strong>正确的输入</strong>，并得到预期的结果。</p>

<p>​       D：Design，<strong>与设计文档相结合</strong>，来编写单元测试。</p>

<p>​       E：Error，<strong>强制错误信息输入</strong>（如：非法数据、异常流程、业务允许外等），并得到预期的结果。</p>

<p>10.【推荐】对于<strong>数据库</strong>相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。</p>

<p>11.【推荐】和<strong>数据库</strong>相关的单元测试，可以设定<strong>自动回滚机制</strong>，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。</p>

<p>12.【推荐】对于<strong>不可测</strong>的代码在适当的时机做必要的<strong>重构</strong>，使代码变得可测，<strong>避免</strong>为了达到测试要求而书写<strong>不规范测试代码</strong>。</p>

<p>13.【推荐】在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试最好覆盖所有测试用例（UC）。</p>

<p>14.【推荐】单元测试作为一种质量保障手段，在项目提测前完成单元测试，不建议项目发布后补充单元测试用例。</p>

<p>15.【参考】为了更方便地进行单元测试，业务代码应<strong>避免</strong>以下情况：</p>

<p>​      构造方法中做的事情过多。</p>

<p>​      存在过多的全局变量和静态方法。</p>

<p>​      存在过多的外部依赖。</p>

<p>​      存在过多的条件语句。</p>

<p>​      说明：多层条件语句建议使用卫语句、策略模式、状态模式等方式重构。</p>

<p>16.【参考】不要对单元测试存在如下误解：</p>

<p>​       <strong>那是测试同学干的事情。本文是开发手册，凡是本文内容都是与开发同学强相关的。</strong></p>

<p>​       单元测试代码是<strong>多余</strong>的。系统的整体功能与各单元部件的测试正常与否是强相关的。</p>

<p>​       单元测试代码<strong>不需要</strong>维护。一年半载后，那么单元测试几乎处于废弃状态。</p>

<p>​       单元测试与线上故障<strong>没有</strong>辩证关系。好的单元测试能够最大限度地规避线上故障。</p>

<h3 id="四-安全规约">四、安全规约</h3>

<p>1.【强制】隶属于用户<strong>个人</strong>的页面或者功能必须进行<strong>权限控制校验</strong>。</p>

<p>2.【强制】用户<strong>敏感数据</strong>禁止直接展示，必须对展示数据进行<strong>脱敏</strong>。</p>

<p>3.【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，<strong>防止 SQL 注入</strong>， 禁止字符串拼接 SQL 访问数据库。</p>

<p>4.【强制】用户请求传入的<strong>任何参数</strong>必须做<strong>有效性验证</strong>。</p>

<p>忽略参数校验可能导致：</p>

<p>​       page size 过大导致内存溢出</p>

<p>​       恶意 order by 导致数据库慢查询</p>

<p>​       缓存击穿</p>

<p>​       SSRF</p>

<p>​       任意重定向</p>

<p>​       SQL 注入，Shell 注入，反序列化注入</p>

<p>​       正则输入源串拒绝服务 ReDoS</p>

<p>​       Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。</p>

<p>5.【强制】<strong>禁止</strong>向 HTML 页面输出未经安全过滤或未正确转义的用户数据。</p>

<p>6.【强制】表单、AJAX 提交必须执行 <strong>CSRF</strong> 安全验证。</p>

<p>CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在 CSRF 漏洞的应用/ 网站，攻击者可以事先构造好 URL，只要受害者用户一访问，后台便在用户不知情的情况下对数据库中用户参数进行相应修改。</p>

<p>7.【强制】URL 外部<strong>重定向</strong>传入的目标地址必须执行<strong>白名单过滤</strong>。</p>

<p>8.【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的<strong>防重放</strong>的机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。</p>

<p>9.【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等<strong>风控策略</strong>。</p>

<h3 id="五-mysql-数据库">五、MySQL 数据库</h3>

<h4 id="一-建表规约">(一) 建表规约</h4>

<p>1.【强制】表达<strong>是与否</strong>概念的字段，必须使用 <strong>is_xxx</strong> 的方式命名，数据类型是 unsigned tinyint （1 表示是，0 表示否）。</p>

<p>2.【强制】表名、字段名必须使用<strong>小写字母或数字</strong>，禁止出现<strong>数字开头</strong>，禁止<strong>两个下划线中间只出现数字</strong>。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p>

<p>3.【强制】表名不使用<strong>复数</strong>名词。</p>

<p>4.【强制】<strong>禁用保留字</strong>，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p>

<p>5.【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx<em>字段名。pk</em> 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。</p>

<p>6.【强制】<strong>小数类型为 decimal</strong>，禁止使用 float 和 double。</p>

<p>7.【强制】如果存储的字符串长度几乎<strong>相等</strong>，使用 <strong>char</strong> 定长字符串类型。</p>

<p>8.【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p>

<p>9.【强制】表必备三字段：id, gmt_create, gmt_modified。其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 <strong>datetime</strong> 类型，前者现在时表示<strong>主动式创建</strong>，后者过去分词表示<strong>被动式更新</strong>。</p>

<p>10.【推荐】表的命名最好是遵循“业务名称_表的作用”。</p>

<p>11.【推荐】<strong>库名</strong>与<strong>应用名称</strong>尽量<strong>一致</strong>。</p>

<p>12.【推荐】如果<strong>修改</strong>字段含义或对字段表示的状态<strong>追加</strong>时，需要及时<strong>更新字段注释</strong>。</p>

<p>13.【推荐】字段允许适当<strong>冗余</strong>，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：</p>

<p>​       1） 不是频繁修改的字段。</p>

<p>​       2） 不是唯一索引的字段。</p>

<p>​       3） 不是 varchar 超长字段，更不能是 text 字段。</p>

<p>14.【推荐】单表行数超过 <strong>500 万行</strong>或者单表容量超过 <strong>2GB</strong>，才推荐进行<strong>分库分表</strong>。</p>

<p>15.【参考】<strong>合适的字符存储长度</strong>，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。</p>

<h4 id="二-索引规约">(二) 索引规约</h4>

<p>1.【强制】业务上具有<strong>唯一</strong>特性的字段，即使是<strong>组合</strong>字段，也必须建成<strong>唯一索引</strong>。</p>

<p>2.【强制】<strong>超过三个表禁止 join</strong>。需要 join 的字段，<strong>数据类型</strong>保持绝对<strong>一致</strong>；多表关联查询时， 保证被关联的字段需要有<strong>索引</strong>。</p>

<p>3.【强制】在 <strong>varchar</strong> 字段上建立索引时，必须<strong>指定索引长度</strong>，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</p>

<p>4.【强制】页面搜索<strong>严禁左模糊</strong>或者<strong>全模糊</strong>，如果需要请走搜索引擎来解决。</p>

<p>5.【推荐】如果有 <strong>order by</strong> 的场景，请注意利用索引的有序性。order by 最后的字段是<strong>组合索引</strong>的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。</p>

<p>6.【推荐】利用<strong>覆盖索引</strong>来进行查询操作，<strong>避免回表</strong>。</p>

<p>7.【推荐】利用<strong>延迟关联</strong>或者<strong>子查询</strong>优化超<strong>多分页</strong>场景。</p>

<p>8.【推荐】SQL 性能优化的目标：至少要达到 <strong>range</strong> 级别，要求是 <strong>ref</strong> 级别，如果可以是 <strong>consts</strong> 最好。</p>

<p>9.【推荐】建<strong>组合索引</strong>的时候，<strong>区分度最高</strong>的在<strong>最左边</strong>。</p>

<p>10.【推荐】防止因<strong>字段类型不同</strong>造成的隐式转换，导致<strong>索引失效</strong>。</p>

<p>11.【参考】创建索引时避免有如下极端误解：</p>

<p>​       1） 索引宁滥勿缺。认为一个查询就需要建一个索引。</p>

<p>​       2） 吝啬索引的创建。认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度。</p>

<p>​       3） 抵制唯一索引。认为唯一索引一律需要在应用层通过“先查后插”方式解决。</p>

<h4 id="三-sql-语句">(三) SQL 语句</h4>

<p>1.【强制】不要使用 count(列名)或 count(常量)来替代 <strong>count(*)</strong>，count(*)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p>

<p>2.【强制】<strong>count(distinct col)</strong> 计算该列除 NULL 之外的不重复行数，注意 <strong>count(distinct col1, col2)</strong> 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</p>

<p>3.【强制】当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 <strong>sum()</strong>时需注意 <strong>NPE</strong> 问题。</p>

<p>4.【强制】使用 <strong>ISNULL()</strong>来判断是否为 NULL 值。</p>

<p><strong>NULL</strong> 与<strong>任何值</strong>的直接比较都为 <strong>NULL</strong>。</p>

<p>​       1） <strong>NULL&lt;&gt;NULL</strong> 的返回结果是 <strong>NULL</strong>，而不是 false。</p>

<p>​       2） <strong>NULL=NULL</strong> 的返回结果是 <strong>NULL</strong>，而不是 true。</p>

<p>​       3） <strong>NULL&lt;&gt;1</strong> 的返回结果是 <strong>NULL</strong>，而不是 true。</p>

<p>5.【强制】代码中写<strong>分页查询逻辑</strong>时，若 <strong>count 为 0 应直接返回</strong>，避免执行后面的分页语句。</p>

<p>6.【强制】不得使用外键与级联，一切<strong>外键</strong>概念必须在<strong>应用层</strong>解决。</p>

<p>（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学 生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机 低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p>

<p>7.【强制】<strong>禁止使用存储过程</strong>，存储过程难以调试和扩展，更没有移植性。</p>

<p>8.【强制】<strong>数据订正</strong>（特别是删除或修改记录操作）时，要<strong>先 select</strong>，避免出现误删除，确认无误才能执行更新语句。</p>

<p>9.【强制】对于数据库中表记录的查询和变更，只要涉及<strong>多个表</strong>，都需要在列名前加表的<strong>别名（或表名）</strong>进行限定。</p>

<p>10.【推荐】SQL 语句中表的别名前加 <strong>as</strong>，并且以 <strong>t1、t2、t3、...</strong>的顺序依次命名。</p>

<p>11.【推荐】<strong>in</strong> 操作能<strong>避免</strong>则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控 制在 <strong>1000</strong> 个之内。</p>

<p>12.【参考】因国际化需要，所有的字符存储与表示，均采用 <strong>utf8</strong> 字符集，那么<strong>字符计数方法</strong>需要注意。</p>

<p>13.【参考】<strong>TRUNCATE</strong> TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 trigger，有可能造成事故，故<strong>不建议</strong>在开发代码中使用此语句。</p>

<h4 id="四-orm-映射">(四) ORM 映射</h4>

<p>1.【强制】在表查询中，一律<strong>不要</strong>使用 ***** 作为查询的字段列表，<strong>需要哪些字段</strong>必须<strong>明确</strong>写明。</p>

<p>2.【强制】<strong>POJO</strong> 类的布尔属性<strong>不能加 is</strong>，而<strong>数据库</strong>字段必须<strong>加 is_</strong>，要求在 <strong>resultMap</strong> 中进行字段与属性之间的<strong>映射</strong>。</p>

<p>3.【强制】不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义<strong>&lt;resultMap&gt;</strong>；反过来，每一个表也必然有一个&lt;resultMap&gt;与之对应。</p>

<p>4.【强制】sql.xml 配置参数使用：<strong>#{}</strong>，#param# 不要使用<strong>${}</strong> 此种方式容易出现 <strong>SQL 注入</strong>。</p>

<p>5.【强制】iBATIS 自带的 <strong>queryForList</strong>(String statementName,int start,int size)<strong>不推荐</strong>使用。</p>

<p>正例：</p>

<p>​       Map<String, Object> map = new HashMap&lt;&gt;();</p>

<p>​       map.put(&quot;start&quot;, start);</p>

<p>​       map.put(&quot;size&quot;, size);</p>

<p>6.【强制】<strong>不允许</strong>直接拿 <strong>HashMap</strong> 与 <strong>Hashtable</strong> 作为查询结果集的<strong>输出</strong>。某同学为避免写一个&lt;resultMap&gt;，直接使用 HashTable 来接收数据库返回结果，结果出现日常是把 bigint 转成 Long 值，而线上由于数据库版本不一样，解析成 BigInteger，导致线上问题。</p>

<p>7.【强制】<strong>更新</strong>数据表记录时，必须同时更新记录对应的 <strong>gmt_modified</strong> 字段值为<strong>当前时间</strong>。</p>

<p>8.【推荐】<strong>不要</strong>写一个<strong>大而全</strong>的<strong>数据更新接口</strong>。传入为 POJO 类，不管是不是自己的目标更新字 段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL 时， 不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。</p>

<p>9.【参考】<strong>@Transactional</strong> 事务<strong>不要滥用</strong>。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</p>

<p>10.【参考】<strong>&lt;isEqual&gt;</strong>中的 <strong>compareValue</strong> 是与属性值对比的常量，一般是数字，表示相等时带上此条件；<strong>&lt;isNotEmpty&gt;</strong>表示<strong>不为空且不为 null</strong> 时执行；<strong>&lt;isNotNull&gt;</strong>表示<strong>不为 null</strong> 值时执行。</p>

<h3 id="六-工程结构">六、工程结构</h3>

<h4 id="一-应用分层">(一) 应用分层</h4>

<p>1.【推荐】图中默认<strong>上层依赖于下层</strong>，箭头关系表示可直接依赖，如：开放接口层可以依赖于 Web 层，也可以直接依赖于 Service 层，依此类推：</p>

<p><img src="https://s1.ax1x.com/2020/06/03/tdAQk6.png" align=center /></p>

<p>• <strong>开放接口层</strong>：可直接封装 Service 方法暴露成 RPC 接口；通过 Web 封装成 http 接口；网关控制层等。</p>

<p>• <strong>终端显示层</strong>：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移 动端展示等。</p>

<p>• <strong>Web 层</strong>：主要是对访问控制进行<strong>转发</strong>，各类基本<strong>参数校验</strong>，或者不复用的业务<strong>简单处理</strong>等。</p>

<p>• <strong>Service 层</strong>：相对<strong>具体</strong>的<strong>业务逻辑</strong>服务层。</p>

<p>• <strong>Manager 层</strong>：通用业务处理层，它有如下特征：</p>

<p>​       1） <strong>对第三方平台封装的层</strong>，预处理返回结果及转化异常信息。</p>

<p>​       2） <strong>对 Service 层通用能力的下沉</strong>，如缓存方案、中间件通用处理。</p>

<p>​       3） <strong>与 DAO 层交互</strong>，对多个 DAO 的组合复用。</p>

<p>• <strong>DAO 层</strong>：<strong>数据访问层</strong>，与底层 MySQL、Oracle、Hbase、OB 等进行数据交互。</p>

<p>• <strong>外部接口或第三方平台</strong>：包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。</p>

<p>2.【参考】（<strong>分层异常处理规约</strong>）在 <strong>DAO 层</strong>，产生的异常类型有很多，无法用细粒度的异常进行 catch，使用 catch(Exception e)方式，并 throw new DAOException(e)，<strong>不需要打印日志</strong>，因为日志在 Manager/Service 层一定需要捕获并打印到日志文件中去，如果同台服务器再打日志， 浪费性能和存储。在 <strong>Service 层</strong>出现异常时，<strong>必须记录出错日志到磁盘</strong>，尽可能带上参数信息，相当于保护案发现场。Manager 层与 Service 同机部署，日志方式与 DAO 层处理一致，如果是单独部署，则采用与 Service 一致的处理方式。<strong>Web 层绝不应该继续往上抛异常</strong>，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到<strong>友好错误页面</strong>， 尽量加上友好的错误提示信息。<strong>开放接口层</strong>要将异常处理成<strong>错误码和错误信息方式</strong>返回。</p>

<p>3.【参考】分层领域模型规约：</p>

<p>• DO（Data Object）：此对象与数据库表结构一一对应，通过 <strong>DAO</strong> 层向上传输数据源对象。</p>

<p>• DTO（Data Transfer Object）：数据传输对象，<strong>Service 或 Manager</strong> 向外传输的对象。</p>

<p>• BO（Business Object）：业务对象，可以由 <strong>Service</strong> 层输出的<strong>封装业务逻辑</strong>的对象。</p>

<p>• Query：<strong>数据查询对象</strong>，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类 来传输。</p>

<p>• VO（View Object）：<strong>显示层对象</strong>，通常是 <strong>Web</strong> 向模板渲染引擎层传输的对象。</p>

<h4 id="二-二方库依赖">(二) 二方库依赖</h4>

<p>1.【强制】定义 GAV 遵从以下规则：</p>

<p>​       1） <strong>G</strong>roupID 格式：com.{公司/BU }.业务线 [.子业务线]，最多 4 级。 说明：{公司/BU} 例如：alibaba/taobao/tmall/aliexpress 等 BU 一级；子业务线可选。 正例：com.taobao.jstorm 或 com.alibaba.dubbo.register</p>

<p>​       2） <strong>A</strong>rtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。 正例：dubbo-client / fastjson-api / jstorm-tool</p>

<p>​       3） <strong>V</strong>ersion：详细规定参考下方。</p>

<p>2.【强制】二方库版本号命名方式：主版本号.次版本号.修订号</p>

<p>​       1）<strong>主版本号</strong>：产品方向改变，或者大规模 API 不兼容，或者架构不兼容升级。</p>

<p>​       2） <strong>次版本号</strong>：保持相对兼容性，增加主要功能特性，影响范围极小的 API 不兼容修改。</p>

<p>​       3） <strong>修订号</strong>：保持完全兼容性，修复 BUG、新增次要功能特性等。</p>

<p>说明：注意起始版本号必须为：1.0.0，而不是 0.0.1。</p>

<p>反例：仓库内某二方库版本号从 1.0.0.0 开始，一直默默“升级”成 1.0.0.64，完全失去版本的语义信息。</p>

<p>3.【强制】线上应用不要依赖 SNAPSHOT 版本（安全包除外）；正式发布的类库必须先去中央仓库进行查证，使 RELEASE 版本号有延续性，且版本号不允许覆盖升级。</p>

<p>4.【强制】二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变， 必须明确评估和验证。</p>

<p>5.【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是<strong>接口返回值不允许</strong>使用<strong>枚举</strong>类型或者包含枚举类型的 POJO 对象。</p>

<p>6.【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。</p>

<p>7.【强制】禁止在子项目的 pom 依赖中出现相同的 GroupId，相同的 ArtifactId，但是不同的 Version。</p>

<p>8.【推荐】底层基础技术框架、核心数据管理平台、或近硬件端系统谨慎引入第三方实现。</p>

<p>9.【推荐】所有 pom 文件中的依赖声明放在语句块中，所有版本仲裁放在 语句块中。</p>

<p>10.【推荐】二方库不要有配置项，最低限度不要再增加配置项。</p>

<p>11.【推荐】不要使用不稳定的工具包或者 Utils 类。</p>

<p>12.【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：</p>

<p>​       1）精简可控原则。移除一切不必要的 API 和依赖，只包含 Service API、必要的领域模型对象、Utils 类、 常量、枚举等。如果依赖其它二方库，尽量是 provided 引入，让二方库使用者去依赖具体版本号；无 log 具体实现，只依赖日志框架。</p>

<p>​       2）稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除 非用户主动升级版本，否则公共二方库的行为不应该发生变化。</p>

<h4 id="三-服务器">(三) 服务器</h4>

<p>1.【推荐】<strong>高并发</strong>服务器建议<strong>调小</strong> TCP 协议的 <strong>time_wait</strong> 超时时间。</p>

<p>2.【推荐】<strong>调大</strong>服务器所支持的最大文件句柄数（File Descriptor，简写为 <strong>fd</strong>）。</p>

<p>3.【推荐】给 JVM 环境参数设置-<strong>XX:+HeapDumpOnOutOfMemoryError</strong> 参数，让 JVM 碰到 <strong>OOM</strong> 场景时<strong>输出 dump 信息</strong>。</p>

<p>4.【推荐】在线上生产环境，JVM 的 <strong>Xms</strong> 和 <strong>Xmx</strong> 设置<strong>一样大小</strong>的内存容量，避免在 GC 后调整堆大小带来的压力。</p>

<p>5.【参考】服务器<strong>内部重定向</strong>必须使用 <strong>forward</strong>；<strong>外部</strong>重定向地址必须使用 <strong>URL Broker</strong> 生成，否则因线上采用 HTTPS 协议而导致浏览器提示“不安全“。此外，还会带来 URL 维护不一致的问题。</p>

<h3 id="七-设计规约">七、设计规约</h3>

<p>1.【强制】<strong>存储方案</strong>和<strong>底层数据结构</strong>的设计获得<strong>评审</strong>一致通过，并沉淀成为文档。</p>

<p>2.【强制】在需求分析阶段，如果与系统交互的 User 超过<strong>一类</strong>并且相关的 User Case 超过 <strong>5 个</strong>， 使用<strong>用例图</strong>来表达更加清晰的结构化需求。</p>

<p>3.【强制】如果某个业务对象的状态超过 <strong>3 个</strong>，使用<strong>状态图</strong>来表达并且明确状态变化的各个触发条件。</p>

<p>状态图的核心是对象状态，首先明确对象有多少种状态，然后明确两两状态之间是否存在直接转换关系，再明确触发状态转换的条件是什么。</p>

<p>淘宝订单状态有已下单、待付款、已付款、待发货、已发货、已收货等。比如已下单与已收货这两种状态之间是不可能有直接转换关系的。</p>

<p>4.【强制】如果系统中某个功能的调用链路上的涉及对象超过 <strong>3 个</strong>，使用<strong>时序图</strong>来表达并且明确 各调用环节的输入与输出。</p>

<p>5.【强制】如果系统中模型类超过 <strong>5 个</strong>，并且存在复杂的<strong>依赖关系</strong>，使用<strong>类图</strong>来表达并且明确类之间的关系。</p>

<p>6.【强制】如果系统中超过 <strong>2 个</strong>对象之间存在<strong>协作</strong>关系，并且需要表示复杂的<strong>处理流程</strong>，使用<strong>活动图</strong>来表示。</p>

<p><strong>活动图</strong>是流程图的扩展，增加了能够体现协作关系的对象泳道，支持表示并发等。</p>

<p>7.【推荐】系统架构设计时明确以下目标：</p>

<p>​       确定<strong>系统边界</strong>。确定系统在技术层面上的做与不做。</p>

<p>​       确定系统内<strong>模块之间的关系</strong>。确定模块之间的依赖关系及模块的宏观输入与输出。</p>

<p>​       确定<strong>指导后续设计与演化的原则</strong>。使后续的子系统或模块设计在一个既定的框架内和技术方向上继续演化。</p>

<p>​       确定<strong>非功能性需求</strong>。非功能性需求是指安全性、可用性、可扩展性等。</p>

<p>8.【推荐】需求分析与系统设计在考虑主干功能的同时，需要<strong>充分</strong>评估<strong>异常流程与业务边界</strong>。</p>

<p>反例：用户在淘宝付款过程中，银行扣款成功，发送给用户扣款成功短信，但是支付宝入款时由于断网演 练产生异常，淘宝订单页面依然显示未付款，导致用户投诉。</p>

<p>9.【推荐】类在设计与实现时要符合<strong>单一</strong>原则。</p>

<p>10.【推荐】<strong>谨慎</strong>使用<strong>继承</strong>的方式来进行扩展，优先使用<strong>聚合/组合</strong>的方式来实现。不得已使用继承的话，必须符合里氏代换原则，此原则说父类能够出现的地方子类一定能够出现， 比如，“把钱交出来”，钱的子类美元、欧元、人民币等都可以出现。</p>

<p>11.【推荐】系统设计阶段，根据<strong>依赖倒置原则</strong>，尽量依赖抽象类与接口，有利于扩展与维护。</p>

<p>12.【推荐】系统设计阶段，注意<strong>对扩展开放</strong>，<strong>对修改闭合</strong>。</p>

<p>13.【推荐】系统设计阶段，共性业务或公共行为<strong>抽取</strong>出来公共模块、公共配置、公共类、公共方法等，在系统中<strong>不出现重复代码</strong>的情况。</p>

<p>14.【推荐】避免如下<strong>误解</strong>：敏捷开发 = 讲故事 + 编码 + 发布。</p>

<p>敏捷开发是快速交付迭代可用的系统，省略多余的设计方案，摒弃传统的审批流程，但核心关键点上 的必要设计和文档沉淀是需要的。</p>

<p>15.【参考】<strong>设计文档</strong>的作用是明确需求、理顺逻辑、后期维护，次要目的用于指导编码。</p>

<p>16.【参考】<strong>可扩展性</strong>的本质是找到<strong>系统的变化点</strong>，并<strong>隔离</strong>变化点。</p>

<p>世间众多设计模式其实就是一种设计模式即隔离变化点的模式。极致扩展性的标志，就是需求的新增，不会在原有代码交付物上进行任何形式的修改。</p>

<p>17.【参考】设计的本质就是识别和表达系统难点。</p>

<p>18.【参考】代码即文档的观点是错误的，清晰的<strong>代码</strong>只是<strong>文档</strong>的某个<strong>片断</strong>，而不是全部。</p>

<p>19.【参考】在做无障碍产品设计时，需要考虑到：</p>

<p>​       1）所有<strong>可交互</strong>的控件元素必须能<strong>被 tab 键聚焦</strong>，并且焦点顺序<strong>需符合自然操作逻辑</strong>。</p>

<p>​       2）用于登陆校验和请求拦截的<strong>验证码</strong>均需提供<strong>图形验证以外的其它方式</strong>。</p>

<p>​       3）<strong>自定义的控件类型需明确交互方式</strong>。</p>

<p>​       正例：用户登陆场景中，输入框的按钮都需要考虑 tab 键聚焦，符合自然逻辑的操作顺序如下，“输入用 户名，输入密码，输入验证码，点击登录”，其中验证码实现语音验证方式。如果有自定义标签实现的控 件设置控件类型可使用 role 属性。</p>
</div>
        <div class="post_footer">
          
          <div class="meta">
            <div class="info">
              <span class="field tags">
                <i class="remixicon-stack-line"></i>
                
                <a href="https://jixinhe111.github.io/tags/%E5%AD%A6%E4%B9%A0/">学习</a>
                
              </span>
            </div>
          </div>
          
        </div>
      </div>
      
      
    </div>
  </div>
  <a id="back_to_top" href="#" class="back_to_top"><span>△</span></a>
</div>
<footer class="footer">
  <div class="powered_by">
    <a href="https://jixnhe111.tk">Finished by jxh,</a>
    <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
  </div>

  <div class="footer_slogan">
    <span>真奇怪</span>
  </div>
</footer>



<script src="https://jixinhe111.github.io/js/jquery-3.3.1.min.js"></script>
<script src="https://jixinhe111.github.io/js/zozo.js"></script>
<script src="https://jixinhe111.github.io/js/highlight.pack.js"></script>
<link  href="https://jixinhe111.github.io/css/fancybox.min.css" rel="stylesheet">
<script src="https://jixinhe111.github.io/js/fancybox.min.js"></script>

<script>hljs.initHighlightingOnLoad()</script>


  <script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>






</body>
</html>
